package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

//TODO: https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/grpc.go#L215

// GenerateHandlerFile generates handler to be implemented.
func GenerateHandlerFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_handler.go"
	println(file.GoImportPath)

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-kit-grpc.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`import(
	"context"
`)
	g.P("pb ", g.QualifiedGoIdent(file.GoImportPath.Ident(strings.Replace(file.GoImportPath.String(), ".", string(file.GoPackageName), 1))))
	g.P(")")

	//create client
	for _, srv := range file.Services {
		g.P("type ", srv.GoName, "Handler struct {")
		g.P("	pb.Unimplemented", srv.GoName, "Server")
		g.P("}")

		for _, method := range srv.Methods {

			g.Annotate(srv.GoName+"."+method.GoName, method.Location)

			g.P(method.Comments.Leading,
				"func ", serverSignature(g, method), " {")
			g.P("//TODO:implement")
			if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				g.P("return nil, nil")
			} else {
				g.P("return nil")
			}

			g.P("}")

		}
	}

	return g
}

func serverSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx context.Context")
		ret = "(*pb." + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "req "+"*pb."+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "stream pb."+method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
